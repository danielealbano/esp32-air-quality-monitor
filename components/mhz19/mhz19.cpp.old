#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "esp_log.h"
#include "driver/uart.h"

#include "mhz19.h"

static const char* TAG = "MHZ19";

static uint32_t millis()
{
    return (uint32_t) (clock() * 1000 / CLOCKS_PER_SEC);
}

/*#########################-Commands-##############################*/

uint8_t Commands[13] = {
	120,
	  // 0 Recovery Reset
	121,
	  // 1 ABC Mode ON/OFF
	132,
	  // 2 Raw CO2
	133,
	  // 3 Temp float, CO2 Unlimited
	134,
	  // 4 Temp integer, CO2 limited
	135, 
	 // 5 Zero Calibration
	136,
	  // 6 Span Calibration
	153, 
	 // 7 Range
	155, 
	 // 8 Get Range
	156,
	  // 9 Get Background CO2
	160,
	  // 10 Get Firmware Version
	162, 
	 // 11 Get Last Response
	163  // 12 Get Temp Calibration
};

/*#####################-Initiation Functions-#####################*/

void MHZ19::begin(uart_port_t uart_num) 
{  
	this->uart_num = uart_num;
    
	/* establish connection */
	verify();

	/* check if successful */
	if (this->errorCode != RESULT_OK) 
	{
#if MHZ19_ERRORS
		ESP_LOGE(TAG, "Initial communication errorCode recieved");
#endif 
	}
}

/*########################-Set Functions-##########################*/

void MHZ19::setRange(int range)
{
	if (range > 65000)
	{
#if MHZ19_ERRORS
		ESP_LOGE(TAG, "Invalid Range value (0 - 65000)");
#endif 

		return;
	}

	else
		provisioning(RANGE, range);
}

void MHZ19::setSpan(int span)
{
	if (span > 10000)
	{
#if MHZ19_ERRORS
		ESP_LOGE(TAG, "Invalid Span value (0 - 10000)");   
#endif 
	}
	else
		provisioning(SPANCAL);
 
	return;
}

void MHZ19::setFilter(bool isON, bool isCleared)
{
	this->storage.settings.filterMode = isON;
	this->storage.settings.filterCleared = isCleared;
}

/*########################-Get Functions-##########################*/

int MHZ19::getCO2(bool isunLimited, bool force)
{
	if (force == true)
	{
		if (isunLimited)
			provisioning(CO2UNLIM);
		else
			provisioning(CO2LIM);
	}

	if (this->errorCode == RESULT_OK || force == false)
	{
		if (!this->storage.settings.filterMode)
		{
			unsigned int validRead = 0;

			if (isunLimited)              
				validRead = makeInt(this->storage.responses.CO2UNLIM[4], this->storage.responses.CO2UNLIM[5]);
			else
				validRead = makeInt(this->storage.responses.CO2LIM[2], this->storage.responses.CO2LIM[3]);

			if (validRead > 32767)
				validRead = 32767;   // Set to maximum to stop negative values being return due to overflow

			else
			     return validRead;   
		}
		else
		{
			/* FILTER BEGIN ----------------------------------------------------------- */
			unsigned int checkVal[2];
			bool trigFilter = false;

			// Filter was must call the opposest unlimited/limited command to work
			if(!isunLimited)                    
			    provisioning(CO2UNLIM);
			else
			    provisioning(CO2LIM);
            
			checkVal[0] = makeInt(this->storage.responses.CO2UNLIM[4], this->storage.responses.CO2UNLIM[5]);
			checkVal[1] = makeInt(this->storage.responses.CO2LIM[2], this->storage.responses.CO2LIM[3]);

			// Limited CO2 stays at 410ppm during reset, so comparing unlimited which instead
			// shows an abormal value, reset duration can be found. Limited CO2 ppm returns to "normal"
			// after reset.

			if(this->storage.settings.filterCleared)
			{
				if (checkVal[0] > 32767 || checkVal[1] > 32767 || (((checkVal[0] - checkVal[1]) >= 10) && checkVal[1] == 410))
				{      
					this->errorCode = RESULT_FILTER;
					return 0;
				}     
			}
			else
			{
				if (checkVal[0] > 32767)
				{
					checkVal[0] = 32767;
					trigFilter = true;
				}
				if (checkVal[1] > 32767)
				{
					checkVal[1] = 32767;
					trigFilter = true;
				}
				if (((checkVal[0] - checkVal[1]) >= 10) && checkVal[1] == 410)
					trigFilter = true;

				if (trigFilter)
				{              
					this->errorCode = RESULT_FILTER;
				}
			}

			if (isunLimited)       
				return checkVal[0];
			else
				return checkVal[1]; 
			/* FILTER END ----------------------------------------------------------- */             
		}              
	}
	return 0;
}

float MHZ19::getCO2Raw(bool force)
{
	if (force == true)
		provisioning(RAWCO2);

	if (this->errorCode == RESULT_OK || force == false)
		return makeInt(this->storage.responses.RAW[2], this->storage.responses.RAW[3]);

	else
		return 0;
}

float MHZ19::getTransmittance(bool force)
{
	if (force == true)
		provisioning(RAWCO2);

	if (this->errorCode == RESULT_OK || force == false)
	{
		float calc = (float)makeInt((this->storage.responses.RAW[2]), this->storage.responses.RAW[3]);

		return (calc * 100 / 35000); //  (calc * to percent / x(raw) zero)
	}

	else
		return 0;
}

float MHZ19::getTemperature(bool isFloat, bool force)
{
	if (isFloat)
	{
		static uint8_t baseTemp = 0;
		static bool isSet = false;

		if (!isSet)
		{
			provisioning(CO2LIM);
			uint8_t buff = (this->storage.responses.CO2LIM[4] - 38);

			baseTemp = buff - (uint8_t)getTemperatureOffset(true);
			isSet = true;
		}
        
		if (force)
			provisioning(CO2UNLIM);

		if (this->errorCode == RESULT_OK || force == false)
		{
			float buff = baseTemp;
			buff += getTemperatureOffset(false);
			return buff;
		}
	}
    
	else if (!isFloat)
	{
		if (force == true)
			provisioning(CO2LIM);

		if (this->errorCode == RESULT_OK || force == false)
			return (this->storage.responses.CO2LIM[4] - 38);
	}
    
	return -273.15;    
}
 
float MHZ19::getTemperatureOffset(bool force)
{
	if (force == true)
		provisioning(CO2UNLIM);

	if (this->errorCode == RESULT_OK || force == false)
	{
		/* Value appears to be for CO2 offset (useful for deriving CO2 from raw?) */
		/* Adjustments and calculations are based on observations of temp behavour */
		float calc = (((this->storage.responses.CO2UNLIM[2] - 8) * 1500) + ((this->storage.responses.CO2UNLIM[3] * 100) * 1 / 17));
		calc /= 100;
		return calc;
	}

	return -273.15;
} 

int MHZ19::getRange()
{
	/* check get range was recieved */
	provisioning(GETRANGE);

	if (this->errorCode == RESULT_OK)
		/* convert MH-Z19 memory value and return */
	return (int)makeInt(this->storage.responses.STAT[4], this->storage.responses.STAT[5]);

	else
	    return 0;
}

uint8_t MHZ19::getAccuracy(bool force)
{
	if (force == true)
		provisioning(CO2LIM);

	if (this->errorCode == RESULT_OK || force == false)
		return this->storage.responses.CO2LIM[5];

	else
		return 0;

	//GetRange uint8_t 7
}

uint8_t MHZ19::getPWMStatus()
{
	//255 156 uint8_t 4;
	return 0;
}

void MHZ19::getVersion(char rVersion[])
{
	provisioning(GETFIRMWARE);

	if (this->errorCode == RESULT_OK)
		for (uint8_t i = 0; i < 4; i++)
		{
			rVersion[i] = char(this->storage.responses.STAT[i + 2]);
		}

	else
		memset(rVersion, 0, 4);
}

int MHZ19::getBackgroundCO2()
{
	provisioning(GETCALPPM);

	if (this->errorCode == RESULT_OK)
		return (int)makeInt(this->storage.responses.STAT[4], this->storage.responses.STAT[5]);

	else
		return 0;
}

uint8_t MHZ19::getTempAdjustment()
{
	provisioning(GETEMPCAL);

	/* 40 is returned here, however this library deductes -2 
	 when using temperature function as it appears inaccurate, 
	*/

	if (this->errorCode == RESULT_OK)
		return (this->storage.responses.STAT[3]);

	else
		return 0;
}

uint8_t MHZ19::getLastResponse(uint8_t bytenum)
{
	provisioning(GETLASTRESP);

	if (this->errorCode == RESULT_OK)
		return (this->storage.responses.STAT[bytenum]);

	else
		return 0;
}

/*######################-Utility Functions-########################*/

void MHZ19::verify()
{
	unsigned long timeStamp = millis();

	/* construct common command (133) */
	constructCommand(CO2UNLIM);

	write(this->storage.constructedCommand);

	while (read(this->storage.responses.CO2UNLIM, CO2UNLIM) != RESULT_OK)
	{
		if (millis() - timeStamp >= TIMEOUT_PERIOD)
		{
#if MHZ19_ERRORS
			ESP_LOGE(TAG, "Failed to verify connection(1) to sensor.");   
#endif   

			return;
		}
	}

	/* construct & write last response command (162) */
	constructCommand(GETLASTRESP);
	write(this->storage.constructedCommand);
    
	/* update timeStamp  for next comms iteration */ 
	timeStamp = millis();

	while (read(this->storage.responses.STAT, GETLASTRESP) != RESULT_OK)
	{
		if (millis() - timeStamp >= TIMEOUT_PERIOD)
		{
#if MHZ19_ERRORS
			ESP_LOGE(TAG, "Failed to verify connection(2) to sensor.");   
#endif
            
			return;
		}
	}      

	/* compare CO2 & temp bytes, command(133), against last response bytes, command (162)*/
	for (uint8_t i = 2; i < 6; i++)
	{
		if (this->storage.responses.CO2UNLIM[i] != this->storage.responses.STAT[i])
		{
#if MHZ19_ERRORS
			ESP_LOGE(TAG, "Last response is not as expected, verification failed.");   
#endif

			return;
		}
	}
	return;
}

void MHZ19::autoCalibration(bool isON, uint8_t ABCPeriod)
{
	/* If ABC is ON */
	if (isON)
	{
		/* If a period was defined */
		if (ABCPeriod)
		{
			/* Catch values out of range */
			if (ABCPeriod >= 24)
				ABCPeriod = 24;

			/* Convert to bytes */
			ABCPeriod *= 6.7;
		}      
		/* If no period was defined (for safety, even though default argument is given)*/
		else
		    ABCPeriod = 160;     // Default bytes
	} 
	/* If ABC is OFF */
	else  
	    ABCPeriod = 0x00;                       // Set command uint8_t to Zero to match command format.     

	/* Update storage */  
	this->storage.settings.ABCRepeat = !isON;   // Set to opposite, as repeat command is sent only when ABC is OFF.

	provisioning(ABC, ABCPeriod);
}

void MHZ19::calibrateZero(int rangeCal)
{
	if (rangeCal)
	{
		int rangevalues[11] = {
			400,
			1000,
			1500,
			2000,
			3000,
			4000,
			5000,
			6000,
			7000,
			8000,
			10000 
		};

		uint8_t result = 0;

		for (uint8_t i = 0; i < 11; i++)
		{
			if (i == 10)
			{
				result = (i + 8);
				break;
			}

			else if ((rangevalues[i] + (rangevalues[i + 1])) / 2 > rangeCal)
			{
				result = (i + 8);
				break;
			}
		}

		provisioning(ZEROCAL, result);
	}

	else
		provisioning(ZEROCAL);
}

void MHZ19::recoveryReset()
{
	provisioning(RECOVER);
}

void MHZ19::printCommunication(bool isDec, bool isPrintComm)
{
	this->storage.settings._isDec = isDec;
	this->storage.settings.printcomm = isPrintComm;
}

/*######################-Inernal Functions-########################*/

void MHZ19::provisioning(Command_Type commandtype, int inData)
{
	/* construct command */
	constructCommand(commandtype, inData);

	/* write to serial */
	write(this->storage.constructedCommand);

	/*return response */
	handleResponse(commandtype);

	/* Check if ABC_OFF needs to run */
	ABCCheck();
}

void MHZ19::constructCommand(Command_Type commandtype, int inData)
{
	/* values for conversions */
	uint8_t High;
	uint8_t Low;

	/* Temporary holder */
	uint8_t asemblecommand[9];

	/* prepare arrays */
	memset(asemblecommand, 0, 9);
	memset(this->storage.constructedCommand, 0, 9);

	/* set address to 'any' */
	asemblecommand[0] = 255;  ///(0xFF) 255/FF means 'any' address (where the sensor is located)

	/* set  register */
	asemblecommand[1] = 1;  //(0x01) arbitrary uint8_t number

	/* set command */
	asemblecommand[2] = Commands[commandtype];  // assign command value

	switch(commandtype)
	{
	case RECOVER:
		break;
	case ABC:
		if (this->storage.settings.ABCRepeat == false)
			asemblecommand[3] = inData;
		break;
	case RAWCO2:
		break;
	case CO2UNLIM:
		break;
	case CO2LIM:
		break;
	case ZEROCAL:
		if (inData)
			asemblecommand[6] = inData;
		break;
	case SPANCAL:
		makeByte(inData, &High, &Low);
		asemblecommand[3] = High;
		asemblecommand[4] = Low;
		break;
	case RANGE:
		makeByte(inData, &High, &Low);
		asemblecommand[6] = High;
		asemblecommand[7] = Low;
		break;
	case GETRANGE:
		break;
	case GETCALPPM:
		break;
	case GETFIRMWARE:
		break;
	case GETEMPCAL:
		break;
	case GETLASTRESP:
		break;
	}

	/* set checksum */
	asemblecommand[8] = getCRC(asemblecommand);

	/* copy bytes from asemblecommand to constructedCommand */
	memcpy(this->storage.constructedCommand, asemblecommand, 9);
}

void MHZ19::write(uint8_t toSend[])
{
	size_t length = 0;
	uint8_t buf[50];

	if (this->storage.settings.printcomm == true)
		printstream(toSend, true, this->errorCode);

	/* empty the uart buffer before sending commands */
	do
	{
		ESP_ERROR_CHECK(uart_get_buffered_data_len(this->uart_num, (size_t*)&length));
		if (length > 0)
		{
			uart_read_bytes(this->uart_num, buf, length > 50 ? 50 : length, 100);
		}
	}
	while(length > 0);
    
	uart_write_bytes(this->uart_num, (const char*)toSend, 9);

 	ESP_ERROR_CHECK(uart_flush(this->uart_num));
}

uint8_t MHZ19::read(uint8_t inBytes[9], Command_Type commandnumber)
{
	size_t length = 0;

	/* loop escape */
	unsigned long timeStamp = millis();

	/* prepare memory array with unsigned chars of 0 */
	memset(inBytes, 0, 9);

	/* prepare errorCode */
	this->errorCode = RESULT_NULL;

	/* wait for response, allow for defined time before exit */
	do
	{
		ESP_ERROR_CHECK(uart_get_buffered_data_len(this->uart_num, (size_t*)&length));

		if (millis() - timeStamp >= TIMEOUT_PERIOD) 
		{
#if MHZ19_ERRORS
			ESP_LOGW(TAG, "Timed out waiting for response");    
#endif  

			this->errorCode = RESULT_TIMEOUT;
			return RESULT_TIMEOUT;
		}
	}
	while(length <= 0);
    
	/* response recieved, read buffer */
	uart_read_bytes(this->uart_num, inBytes, 9, 1000);

	if (this->errorCode == RESULT_TIMEOUT)
		return this->errorCode;

	uint8_t crc = getCRC(inBytes);

	/* CRC error will not overide match error */
	if (inBytes[8] != crc)
		this->errorCode = RESULT_CRC;

	/* construct error code */
	if (inBytes[0] != this->storage.constructedCommand[0] || inBytes[1] != this->storage.constructedCommand[2])
		this->errorCode = RESULT_MATCH;

	/* if error has been assigned */
	if (this->errorCode == RESULT_NULL)
		this->errorCode = RESULT_OK;

	/* print results */
	if (this->storage.settings.printcomm == true)
		printstream(inBytes, false, this->errorCode);

	return this->errorCode;
}

void MHZ19::handleResponse(Command_Type commandtype)
{
	if (this->storage.constructedCommand[2] == Commands[2])      // compare commands byte
	    read(this->storage.responses.RAW, commandtype);             // returns error number, passes back response and inputs command

	else if(this->storage.constructedCommand[2] == Commands[3])
	    read(this->storage.responses.CO2UNLIM, commandtype);

	else if(this->storage.constructedCommand[2] == Commands[4])
	    read(this->storage.responses.CO2LIM, commandtype);

	else
	    read(this->storage.responses.STAT, commandtype);
}

void MHZ19::printstream(uint8_t inBytes[9], bool isSent, uint8_t pserrorCode)
{
	isSent ? printf("Sent << ") : printf("Recieved >> ");

	if (this->storage.settings._isDec)
	{
		printf("DEC: ");
		for (uint8_t i = 0; i < 9; i++)
		{
			printf("%d ", inBytes[i]);
		}
	}
	else
	{
		printf("HEX: ");
		for (uint8_t i = 0; i < 9; i++)
		{
			printf("0x%02x ", inBytes[i]);
		}
	}

	if (pserrorCode != RESULT_OK && isSent == false)
	{
		printf("ERROR CODE: %d", pserrorCode);
	}

	printf("\n");
}

uint8_t MHZ19::getCRC(uint8_t inBytes[])
{
	/* as shown in datasheet */
	uint8_t x = 0, CRC = 0;

	for (x = 1; x < 8; x++)
	{
		CRC += inBytes[x];
	}

	CRC = 255 - CRC;
	CRC++;

	return CRC;
}

void MHZ19::ABCCheck()
{  
	/* check timer interval if dynamic hours have passed and if ABC_OFF was set to true */
	if (((millis() - ABCRepeatTimer) >= 4.32e7) && (this->storage.settings.ABCRepeat == true))
	{
		/* update timer inerval */
		ABCRepeatTimer = millis();

		/* construct ABC_OFF command */
		constructCommand(ABC);

		/* write to serial */
		write(this->storage.constructedCommand);
	}
}

void MHZ19::makeByte(int inInt, uint8_t *high, uint8_t *low)
{
	*high = (uint8_t)(inInt / 256);
	*low = (uint8_t)(inInt % 256);

	return;
}

unsigned int MHZ19::makeInt(uint8_t high, uint8_t low)
{
	unsigned int calc = ((unsigned int)high * 256) + (unsigned int)low;
 
	return calc;
}
